using System;
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using System.CodeDom.Compiler;
using System.IO;
using System.Linq;
using StringEnumGenerator.Generator.Model;
using StringEnumGenerator.Generator.Utils;

namespace StringEnumGenerator.Generator
{
    public class ClassGenerator
    {
        private readonly EnumContext _enumContext;

        internal static string GenerateSource(EnumContext enumContext, SemanticModel semanticModel)
        {
            return new ClassGenerator(enumContext).GenerateSource();
        }

        private ClassGenerator(EnumContext enumContext)
        {
            _enumContext = enumContext;
        }

        private string GenerateSource()
        {
            using var writer = new StringWriter();
            var sourceWriter = new IndentedTextWriter(writer);

            sourceWriter.WriteLine("// <auto-generated />");
            sourceWriter.WriteLine("#nullable enable");
            sourceWriter.WriteLine("using System.Collections.Generic;");
            sourceWriter.WriteLine("using System;");
            sourceWriter.WriteLine("using System.Diagnostics.CodeAnalysis;");
            sourceWriter.WriteLine("using System.Collections.Immutable;");
            sourceWriter.WriteLine("using System.Threading;");

            GenerateNamespace(sourceWriter);
            using (sourceWriter.Scope())
            {
                List<IDisposable> containingTypeScopes = new();
                var containingTypes = _enumContext.Symbol.GetContainingTypes();
                foreach (var containingType in containingTypes.Reverse())
                {
                    AddClassHeader(sourceWriter, containingType);
                    containingTypeScopes.Add(sourceWriter.Scope());
                }

                new EnumGenerator(_enumContext, sourceWriter).Generate();

                foreach (var scope in containingTypeScopes)
                {
                    scope.Dispose();
                }
            }

            sourceWriter.Flush();
            return writer.GetStringBuilder().ToString();
        }

        private void GenerateNamespace(IndentedTextWriter sourceWriter)
        {
            string namespaceDeclaration = _enumContext.Symbol.ContainingNamespace.ToDisplayString(
                new SymbolDisplayFormat(
                    SymbolDisplayGlobalNamespaceStyle.OmittedAsContaining,
                    SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
                    kindOptions: SymbolDisplayKindOptions.IncludeNamespaceKeyword));

            sourceWriter.WriteLine(namespaceDeclaration);
        }

        private void AddClassHeader(IndentedTextWriter sourceWriter, INamedTypeSymbol typeSymbol)
        {
            string typeDeclaration = typeSymbol.ToDisplayString(new SymbolDisplayFormat(
                SymbolDisplayGlobalNamespaceStyle.Included,
                SymbolDisplayTypeQualificationStyle.NameOnly,
                SymbolDisplayGenericsOptions.IncludeTypeParameters,
                SymbolDisplayMemberOptions.IncludeModifiers,
                kindOptions: SymbolDisplayKindOptions.IncludeTypeKeyword));

            sourceWriter.WriteLine("partial " + typeDeclaration);
        }
    }
}
